
# Лабораторная работа: Решение задач линейного программирования (двухфазный симплекс)

**Ф.И.О.:** *Ермаков Максим Олегович*  
**Поток:** *1.1*

---

## Краткое описание алгоритма решения ЗЛП

Задача линейного программирования (ЗЛП) решается программой, реализующей **двухфазный симплекс‑метод** c автоматическим приведением к каноническому виду.

### 1) Схема по ГОСТ 19.701‑90 (блок‑схема в текстовом виде)

```
┌───────────────────────────────────────────────┐
│ НАЧАЛО                                        │
└───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────┐
│ Ввод постановки ЗЛП из текстового файла       │
│ - тип задачи: min/max                         │
│ - вектор c                                    │
│ - матрица A, знаки ограничений, вектор b      │
└───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────┐
│ Приведение к каноническому виду               │
│ - b<0 → умножить строку на −1 и инвертировать │
│   знак ограничения                            │
│ - для '<=' добавить добавочные (slack) s      │
│ - для '>=' добавить избыточные (surplus) t    │
│   со знаком '−' и искусственные a             │
│ - для '=' добавить искусственные a            │
│ - сформировать базис                           │
└───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────┐
│ Фаза I: формирование вспомогательной задачи   │
│ max  −∑a и построение исходного симплекс‑      │
│ таблицы. Искусственные базисные → вычесть их  │
│ строки из строки цели.                        │
└───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────┐
│ Симплекс‑итерации (Фаза I)                    │
│ - выбор входящей: самый левый c̄_j < 0 (Бланд) │
│ - выбор выходящей: тест отношения (b_i/a_ij)  │
│ - поворот (пивот) и обновление базиса         │
└───────────────────────────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────────┐
│ Оптимальность Фазы I?  (все c̄_j ≥ 0)          │
└───────────────────────────────────────────────┘
          │                     │
        НЕТ                     ДА
          │                     │
          ▼                     ▼
┌──────────────────────┐   ┌──────────────────────────────────────┐
│ Цикл итераций далее  │   │ Значение цели Фазы I = 0 ?           │
└──────────────────────┘   └──────────────────────────────────────┘
                                   │                 │
                                  НЕТ               ДА
                                   │                 │
                                   ▼                 ▼
                        ┌─────────────────┐   ┌────────────────────────────────┐
                        │ Задача невыпол- │   │ Удалить столбцы искусственных  │
                        │нима (infeasible)│   │ переменных, восстановить целевую │
                        └─────────────────┘   │ функцию исходной задачи,        │
                                              │ скорректировать строку цели.    │
                                              └────────────────────────────────┘
                                                                │
                                                                ▼
                                              ┌────────────────────────────────┐
                                              │ Фаза II: симплекс‑итерации     │
                                              │ до оптимальности (все c̄_j ≥ 0)│
                                              └────────────────────────────────┘
                                                                │
                                                                ▼
                                              ┌────────────────────────────────┐
                                              │ Результат: x*, значение цели   │
                                              │ или unbounded                  │
                                              └────────────────────────────────┘
                                                                │
                                                                ▼
                                           ┌────────────────────────────────────┐
                                           │ КОНЕЦ                              │
                                           └────────────────────────────────────┘
```

### 2) Псевдокод алгоритма (двухфазный симплекс)

```text
read(sense, c, A, signs, b)
# Приведение к каноническому
for i in rows:
    if b[i] < 0:
        A[i] := -A[i]; b[i] := -b[i]; invert(signs[i])

add slack s for '<=', add surplus (−t) and artificial a for '>='
add artificial a for '='
build initial basis (slacks + artificials)

# Фаза I
build tableau T for objective max -sum(a)
repeat:
    choose entering j = leftmost column with reduced cost < 0
    if no such j: break (optimum of phase I)
    choose leaving i by ratio test b_i / a_ij with a_ij > 0
    if none: return UNBOUNDED
    pivot(T, i, j)

if objective(T) < 0: return INFEASIBLE

# Переход к фазе II
remove artificial columns
build original objective (max -c^T x for min) in z-row
for each basic column k with cost c_k: z := z + c_k * row(k)

# Фаза II
repeat simplex iterations until all reduced costs >= 0

return x* from basic columns, objective (flip sign for min)
```

---

## Инструкция: как развернуть и запустить

### Вариант А. Через терминал
```bash
python -m venv .venv
source .venv/bin/activate         # macOS/Linux
# .venv\Scripts\activate          # Windows

pip install numpy

python two_phase_simplex.py example_lp.txt
```

### Вариант Б. PyCharm
1. Run → Edit Configurations → *Parameters* → `example_lp.txt` (или полный путь).  
2. Запуск конфигурации.

### Формат входного файла
```
min|max
c1 c2 ... cn
a11 a12 ... a1n  <=|=|>=  b1
...
am1 am2 ... amn  <=|=|>=  bm
end
```
Все переменные неотрицательные: `x >= 0`.

---

## Демонстрация работы программы

### Вариант задания
Минимизировать
\[
Z = x_1 + 4x_2 + 2x_3 + x_4
\]
при ограничениях
\[
\begin{aligned}
x_1 + x_2 + 2x_3 &\le 6,\\
x_2 + x_3 + x_4 &= 4,\\
2x_1 + x_4 &\ge 3,\\
x_i &\ge 0.
\end{aligned}
\]

**Содержимое `example_lp.txt`:**
```
min
1 4 2 1
1 1 2 0 <= 6
0 1 1 1 = 4
2 0 0 1 >= 3
end
```

**Результат запуска:**
```
status: optimal
x*: 0 0 0 4
objective: 4
```

Совпадает с решением MS Excel («Поиск решения»): \(x^*=(0,0,0,4)\), \(Z_{\min}=4\).

---

## Рефлективный вывод

В работе реализован полный цикл решения ЗЛП без готовых оптимизаторов (только `numpy`): парсинг файла, перевод к каноническому виду, Фаза I (вспомогательная задача), Фаза II (основная задача), вывод результата.  
Полезно было:
- отработать добавление добавочных/избыточных/искусственных переменных;
- использовать правило Бланда для устойчивости;
- корректно восстанавливать строку цели при переходе к Фазе II.

Трудности:
- удаление искусственных переменных, если они в базисе — решено дополнительным «выпивотом»;
- численная устойчивость и пороги сравнения (1e−10).

Итог: получен воспроизводимый инструмент, дающий результат, идентичный Excel на тестовом примере.
